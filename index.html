<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Overlay Chat 3D Illuminati - felipecanneli</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Fredoka+One&display=swap');
        
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: transparent !important;
            font-family: 'Fredoka One', cursive;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            background: transparent;
        }
    </style>
    <!-- Bibliotecas essenciais com redundância de CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>
    <script src="https://cdn.bundle.js/tmi.js@1.8.5"></script>
</head>
<body>
    <div id="canvas-container"></div>

    <script>
        /**
         * CONFIGURAÇÕES ILLUMINATI NICK - felipecanneli
         */
        const TWITCH_CHANNEL = 'felipecanneli';
        
        const COLORS = {
            orange: new THREE.Color(0xFF5C00),
            white: new THREE.Color(0xFFFFFF),
            slime: new THREE.Color(0xCCFF00),
            pink: new THREE.Color(0xFF00FF),
            blue: new THREE.Color(0x00E5FF),
        };

        const CONFIG = {
            depth: 60,
            blockGap: 220, 
            maxMessages: 5,
            offsetX: -420, 
            offsetY: -450,
        };

        let scene, camera, renderer, clock;
        const messagesGroup = new THREE.Group();
        const activeBlocks = [];

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.1, 5000);
            camera.position.set(0, 0, 1350);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            
            renderer.toneMapping = THREE.LinearToneMapping;
            renderer.toneMappingExposure = 1.0;
            
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
            dirLight.position.set(300, 600, 500);
            scene.add(dirLight);

            scene.add(messagesGroup);
            clock = new THREE.Clock();

            animate();
            
            // Tenta conectar à Twitch após o carregamento inicial
            checkTmiAndConnect();

            // Mensagem de Inicialização VISÍVEL
            create3DMessage("SYSTEM", "CARREGANDO ILLUMINATI...");
        }

        async function checkTmiAndConnect() {
            let attempts = 0;
            const maxAttempts = 10;
            
            const timer = setInterval(() => {
                attempts++;
                if (typeof tmi !== 'undefined') {
                    clearInterval(timer);
                    connectTwitch();
                } else if (attempts >= maxAttempts) {
                    clearInterval(timer);
                    console.error("TMI.js falhou em carregar após várias tentativas.");
                }
            }, 500);
        }

        function connectTwitch() {
            const client = new tmi.Client({ 
                connection: { secure: true, reconnect: true },
                channels: [TWITCH_CHANNEL] 
            });
            client.connect()
                .then(() => create3DMessage("TWITCH", "CONECTADO AO CANAL!"))
                .catch(console.error);
            
            client.on('message', (channel, tags, message, self) => {
                if (self) return;
                const user = tags['display-name'] || tags.username;
                create3DMessage(user, message);
            });
        }

        function createCheckerTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#FFFFFF';
            ctx.fillRect(0,0,128,128);
            ctx.fillStyle = '#000000';
            ctx.fillRect(0,0,64,64);
            ctx.fillRect(64,64,64,64);
            const tex = new THREE.CanvasTexture(canvas);
            tex.repeat.set(2, 0.5);
            tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
            return tex;
        }

        function createTextTexture(user, text) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 1024; canvas.height = 512;

            // Fundo Laranja Nick Puro
            ctx.fillStyle = '#FF5C00';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Brilho Plástico Superior
            const grad = ctx.createLinearGradient(0,0,0,512);
            grad.addColorStop(0, 'rgba(255,255,255,0.4)');
            grad.addColorStop(0.3, 'rgba(255,255,255,0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0,0,1024,512);

            // Nome do Usuário (Glow Neon)
            ctx.shadowColor = '#CCFF00';
            ctx.shadowBlur = 20;
            ctx.font = 'bold 70px Fredoka One';
            ctx.fillStyle = '#CCFF00';
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 14;
            ctx.strokeText(user.toUpperCase(), 60, 110);
            ctx.fillText(user.toUpperCase(), 60, 110);
            
            // Mensagem (Contraste Máximo)
            ctx.shadowBlur = 0;
            ctx.font = 'bold 85px Fredoka One';
            ctx.fillStyle = '#FFFFFF';
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 10;

            const words = text.split(' ');
            let line = ''; let y = 230;
            for(let n = 0; n < words.length; n++) {
                let testLine = line + words[n] + ' ';
                if (ctx.measureText(testLine).width > 880 && n > 0) {
                    ctx.strokeText(line, 60, y);
                    ctx.fillText(line, 60, y);
                    line = words[n] + ' ';
                    y += 105;
                    if (y > 480) break;
                } else { line = testLine; }
            }
            ctx.strokeText(line, 60, y);
            ctx.fillText(line, 60, y);

            const tex = new THREE.CanvasTexture(canvas);
            tex.needsUpdate = true;
            return tex;
        }

        function createEye() {
            const eyeGroup = new THREE.Group();
            const eyeball = new THREE.Mesh(
                new THREE.SphereGeometry(25, 24, 24),
                new THREE.MeshPhysicalMaterial({ color: 0xffffff, roughness: 0.1, clearcoat: 1.0 })
            );
            eyeGroup.add(eyeball);

            const iris = new THREE.Mesh(
                new THREE.SphereGeometry(14, 24, 24),
                new THREE.MeshBasicMaterial({ color: 0xFF00FF })
            );
            iris.position.z = 18;
            iris.scale.z = 0.5;
            eyeGroup.add(iris);

            const pupil = new THREE.Mesh(
                new THREE.SphereGeometry(7, 24, 24),
                new THREE.MeshBasicMaterial({ color: 0x000000 })
            );
            pupil.position.z = 24;
            pupil.scale.z = 0.4;
            eyeGroup.add(pupil);

            return eyeGroup;
        }

        function create3DMessage(user, text) {
            const w = 380, h = 160, radius = 50;
            const shape = new THREE.Shape();
            shape.moveTo(-w/2 + radius, -h/2);
            shape.lineTo(w/2 - radius, -h/2);
            shape.quadraticCurveTo(w/2, -h/2, w/2, -h/2 + radius);
            shape.lineTo(w/2, h/2 - radius);
            shape.quadraticCurveTo(w/2, h/2, w/2 - radius, h/2);
            shape.lineTo(-w/2 + radius, h/2);
            shape.quadraticCurveTo(-w/2, h/2, -w/2, h/2 - radius);
            shape.lineTo(-w/2, -h/2 + radius);
            shape.quadraticCurveTo(-w/2, -h/2, -w/2 + radius, -h/2);

            const geometry = new THREE.ExtrudeGeometry(shape, { 
                depth: CONFIG.depth, bevelEnabled: true, bevelThickness: 15, bevelSize: 12, bevelSegments: 10 
            });

            // Material da Face frontal com brilho próprio (para ser legível sempre)
            const matFront = new THREE.MeshBasicMaterial({ 
                map: createTextTexture(user, text)
            });

            // Laterais Quadriculadas Neon
            const matSide = new THREE.MeshPhysicalMaterial({ 
                map: createCheckerTexture(), 
                color: 0xffffff, 
                emissive: 0xffffff,
                emissiveIntensity: 0.8, // Glow nas laterais
                roughness: 0.1, 
                clearcoat: 1.0 
            });

            const mesh = new THREE.Mesh(geometry, [matFront, matSide]);
            const group = new THREE.Group();
            group.add(mesh);

            // Olhos Illuminati
            const eyes = [];
            for(let i = 0; i < 3; i++) {
                const eye = createEye();
                group.add(eye);
                eyes.push({
                    mesh: eye,
                    angle: (i / 3) * Math.PI * 2,
                    speed: 1.2 + Math.random() * 1.5,
                    radius: 300 + Math.random() * 80,
                    offsetY: (Math.random() - 0.5) * 120
                });
            }

            // Slime GOSMENTO
            const slimes = [];
            for(let i = 0; i < 12; i++) {
                const sGeo = new THREE.SphereGeometry(15 + Math.random() * 18, 16, 16);
                const sMat = new THREE.MeshPhysicalMaterial({ 
                    color: COLORS.slime, 
                    emissive: COLORS.slime, 
                    emissiveIntensity: 0.9, 
                    transparent: true, 
                    opacity: 0.95 
                });
                const sMesh = new THREE.Mesh(sGeo, sMat);
                const px = (Math.random() - 0.5) * (w + 40);
                sMesh.position.set(px, -h/2, Math.random() * CONFIG.depth);
                group.add(sMesh);
                slimes.push({ 
                    mesh: sMesh, speed: 1.5 + Math.random() * 2, offset: Math.random() * 10, 
                    bx: px, by: -h/2, dripLimit: 140 + Math.random() * 120 
                });
            }

            // Inicia fora da tela à esquerda e escala de 0 a 1
            group.position.set(-1500, CONFIG.offsetY, 0);
            group.scale.set(0.01, 0.01, 0.01);
            messagesGroup.add(group);
            
            activeBlocks.push({ obj: group, slimes, eyes, seed: Math.random() * 100 });

            // Animação de Entrada GSAP
            gsap.to(group.scale, { x: 1, y: 1, z: 1, duration: 0.8, ease: "back.out(1.7)" });

            if (activeBlocks.length > CONFIG.maxMessages) {
                const old = activeBlocks.shift();
                gsap.to(old.obj.scale, { x: 0, y: 0, z: 0, duration: 0.5, onComplete: () => {
                    messagesGroup.remove(old.obj);
                }});
            }

            updateStack();
        }

        function updateStack() {
            activeBlocks.forEach((block, index) => {
                const rev = activeBlocks.length - 1 - index;
                // Posicionamento X e Y dinâmico para subir as mensagens
                gsap.to(block.obj.position, {
                    x: CONFIG.offsetX, 
                    y: (rev * CONFIG.blockGap) + CONFIG.offsetY,
                    duration: 1.2,
                    ease: "elastic.out(1, 0.7)"
                });
                
                // Diminui olhos conforme sobe
                const eyeScale = Math.max(0, 1 - (rev * 0.35)); 
                block.eyes.forEach(e => {
                    gsap.to(e.mesh.scale, { x: eyeScale, y: eyeScale, z: eyeScale, duration: 0.8 });
                });
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            const t = clock.getElapsedTime();

            activeBlocks.forEach((block, i) => {
                const phase = t + i;
                block.obj.rotation.x = Math.sin(phase * 0.7) * 0.12;
                block.obj.rotation.y = Math.cos(phase * 0.5) * 0.15;

                // Orbitar Olhos
                block.eyes.forEach(e => {
                    const orbitAngle = t * e.speed + e.angle;
                    e.mesh.position.x = Math.cos(orbitAngle) * e.radius;
                    e.mesh.position.z = Math.sin(orbitAngle) * e.radius;
                    e.mesh.position.y = Math.sin(t * 2.5 + e.angle) * 40 + e.offsetY;
                    e.mesh.lookAt(0, 0, 0);
                });

                // Slime Drip (Pinga com aceleração)
                block.slimes.forEach(s => {
                    const localT = t * s.speed + s.offset;
                    let dripCycle = (Math.sin(localT) + 1) / 2;
                    let dripFactor = Math.pow(dripCycle, 2.5);
                    const stretch = 1 + (dripFactor * 8.5); 
                    s.mesh.scale.set(1 / Math.sqrt(stretch), stretch, 1 / Math.sqrt(stretch));
                    s.mesh.position.y = s.by - (dripFactor * s.dripLimit);
                    s.mesh.material.emissiveIntensity = 0.5 + (dripCycle * 1.0);
                });
            });

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        window.onload = init;
    </script>
</body>
</html>
