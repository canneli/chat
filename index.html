<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Overlay Chat 3D - felipecanneli</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Fredoka+One&display=swap');
        
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: transparent !important;
            font-family: 'Fredoka One', cursive;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            background: transparent;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>
</head>
<body>
    <div id="canvas-container"></div>

    <script>
        /**
         * CONFIGURAÇÕES Y2K - SLIME DINÂMICO E POSICIONAMENTO
         */
        const COLORS = {
            orange: new THREE.Color(0xFF5C00),
            white: new THREE.Color(0xFFFFFF),
            slime: new THREE.Color(0xCCFF00),
            blue: new THREE.Color(0x00E5FF)
        };

        const CONFIG = {
            depth: 55,
            blockGap: 190, 
            maxMessages: 4,
            marginX: -380, // Posição X (afastado da borda esquerda)
            marginY: -420, // Posição inicial Y (base)
            initialMessages: [
                { user: "HATER_01", text: "Esse slime é mais viscoso que a minha paciência." },
                { user: "FAN_BOY", text: "Felipe, as cores estão tão fortes que meus olhos estão a derreter. Lindo!" },
                { user: "TROLL_MASTER", text: "Overlay nota 10, conteúdo nota dó." }
            ]
        };

        let scene, camera, renderer, clock;
        const messagesGroup = new THREE.Group();
        const activeBlocks = [];

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 5000);
            camera.position.set(0, 0, 1100);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);

            const p1 = new THREE.PointLight(0xffffff, 1.2);
            p1.position.set(300, 500, 500);
            scene.add(p1);

            const p2 = new THREE.PointLight(0x00E5FF, 1.5);
            p2.position.set(-500, -300, 300);
            scene.add(p2);

            scene.add(messagesGroup);
            clock = new THREE.Clock();

            animate();

            CONFIG.initialMessages.forEach((msg, i) => {
                setTimeout(() => create3DMessage(msg.user, msg.text), i * 1500);
            });
        }

        function createTextTexture(user, text) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 1024;
            canvas.height = 512;

            const bgGrad = ctx.createLinearGradient(0, 0, 0, 512);
            bgGrad.addColorStop(0, '#FF8A00');
            bgGrad.addColorStop(1, '#FF5C00');
            ctx.fillStyle = bgGrad;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Brilho Glossy Y2K
            ctx.globalAlpha = 0.3;
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.ellipse(512, 0, 950, 350, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1.0;

            ctx.font = 'bold 55px Fredoka One';
            ctx.fillStyle = '#CCFF00';
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 12;
            ctx.strokeText(user.toUpperCase(), 60, 110);
            ctx.fillText(user.toUpperCase(), 60, 110);

            ctx.font = '72px Fredoka One';
            ctx.fillStyle = '#FFFFFF';
            const words = text.split(' ');
            let line = '';
            let y = 240;
            for(let n = 0; n < words.length; n++) {
                let testLine = line + words[n] + ' ';
                if (ctx.measureText(testLine).width > 880 && n > 0) {
                    ctx.fillText(line, 60, y);
                    line = words[n] + ' ';
                    y += 100;
                } else {
                    line = testLine;
                }
            }
            ctx.fillText(line, 60, y);

            return new THREE.CanvasTexture(canvas);
        }

        function create3DMessage(user, text) {
            const width = 360;
            const height = 140;
            const radius = 40;

            const shape = new THREE.Shape();
            shape.moveTo(-width/2 + radius, -height/2);
            shape.lineTo(width/2 - radius, -height/2);
            shape.quadraticCurveTo(width/2, -height/2, width/2, -height/2 + radius);
            shape.lineTo(width/2, height/2 - radius);
            shape.quadraticCurveTo(width/2, height/2, width/2 - radius, height/2);
            shape.lineTo(-width/2 + radius, height/2);
            shape.quadraticCurveTo(-width/2, height/2, -width/2, height/2 - radius);
            shape.lineTo(-width/2, -height/2 + radius);
            shape.quadraticCurveTo(-width/2, -height/2, -width/2 + radius, -height/2);

            const extrudeSettings = { 
                depth: CONFIG.depth, 
                bevelEnabled: true, 
                bevelThickness: 12, 
                bevelSize: 10, 
                bevelSegments: 8 
            };
            
            const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);

            const matFront = new THREE.MeshPhysicalMaterial({
                map: createTextTexture(user, text),
                roughness: 0.1,
                clearcoat: 1.0,
                reflectivity: 1.0
            });

            const matSide = new THREE.MeshPhysicalMaterial({
                color: COLORS.white,
                roughness: 0.1,
                clearcoat: 1.0
            });

            const mesh = new THREE.Mesh(geometry, [matFront, matSide]);
            const group = new THREE.Group();
            group.add(mesh);

            // SISTEMA DE SLIME QUE PINGA (Drip System)
            const slimes = [];
            const numSlimes = 14;
            for(let i = 0; i < numSlimes; i++) {
                const sGeo = new THREE.SphereGeometry(12 + Math.random() * 20, 20, 20);
                const sMat = new THREE.MeshPhysicalMaterial({
                    color: COLORS.slime,
                    emissive: COLORS.slime,
                    emissiveIntensity: 0.4,
                    transparent: true,
                    opacity: 0.95,
                    roughness: 0,
                    clearcoat: 1.0
                });
                const sMesh = new THREE.Mesh(sGeo, sMat);
                const px = (Math.random() - 0.5) * (width + 10);
                const pz = Math.random() * CONFIG.depth;
                sMesh.position.set(px, -height/2, pz);
                group.add(sMesh);
                
                slimes.push({ 
                    mesh: sMesh, 
                    speed: 1.5 + Math.random() * 2.5, 
                    offset: Math.random() * Math.PI * 2, 
                    dripDepth: 80 + Math.random() * 120, // O quanto a gota cai
                    stretchMult: 4 + Math.random() * 4,   // Intensidade do esticamento
                    bx: px 
                });
            }

            group.position.set(-1500, CONFIG.marginY, 0);
            group.scale.set(0.1, 0.1, 0.1);
            messagesGroup.add(group);
            
            activeBlocks.push({ obj: group, slimes, seed: Math.random() * 100 });

            gsap.to(group.scale, { x: 1, y: 1, z: 1, duration: 1, ease: "elastic.out(1, 0.6)" });

            if (activeBlocks.length > CONFIG.maxMessages) {
                const old = activeBlocks.shift();
                gsap.to(old.obj.scale, { x: 0, y: 0, z: 0, duration: 0.5, onComplete: () => {
                    messagesGroup.remove(old.obj);
                    old.obj.traverse(n => {
                        if (n.geometry) n.geometry.dispose();
                        if (n.material) (Array.isArray(n.material) ? n.material : [n.material]).forEach(m => m.dispose());
                    });
                }});
            }
            updateStack();
        }

        function updateStack() {
            activeBlocks.forEach((block, index) => {
                const rev = activeBlocks.length - 1 - index;
                gsap.to(block.obj.position, {
                    x: CONFIG.marginX, 
                    y: (rev * CONFIG.blockGap) + CONFIG.marginY,
                    duration: 1.2,
                    ease: "elastic.out(1, 0.8)"
                });
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            const t = clock.getElapsedTime();

            activeBlocks.forEach((block, i) => {
                const wave = t + i;
                block.obj.rotation.x = Math.sin(wave * 1.0) * 0.1;
                block.obj.rotation.y = Math.cos(wave * 0.6) * 0.12;
                block.obj.rotation.z = Math.sin(wave * 0.3) * 0.05;

                // Pulsar Y2K (Gelatina)
                const wobble = Math.sin(t * 3.0 + block.seed);
                block.obj.scale.y = 1 + wobble * 0.03;
                block.obj.scale.x = 1 - wobble * 0.02;

                // ANIMAÇÃO DE PINGAR (DRIP LOGIC)
                block.slimes.forEach(s => {
                    const dt = t * s.speed + s.offset;
                    // Usando Math.pow para criar um efeito de "aceleração" na queda
                    let dripCycle = (Math.sin(dt) + 1) / 2; // 0 a 1
                    let dripFactor = Math.pow(dripCycle, 1.5); // Favorece a parte inferior do ciclo
                    
                    const str = 1 + (dripFactor * s.stretchMult);
                    
                    // Estica a gota e afina as laterais
                    s.mesh.scale.set(1 / Math.sqrt(str), str, 1 / Math.sqrt(str));
                    
                    // Posicionamento: cai muito mais agora
                    s.mesh.position.y = -70 - (dripFactor * s.dripDepth);
                    
                    // Balanço lateral das gotas para não ficarem duras
                    s.mesh.position.x = s.bx + Math.sin(dt * 1.8) * 12;
                    
                    // Sutil variação de opacidade no auge da queda (opcional)
                    s.mesh.material.opacity = 0.95 - (dripFactor * 0.2);
                });
            });

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        window.onload = init;
    </script>
</body>
</html>
